local versionNumber = 1.1

if not package then os.loadAPI("package") end

local args = {...}

if #args < 1 or (args[1] ~= "install" and args[1] ~= "update" and args[1] ~= "remove" and args[1] ~= "interactive" and args[1] ~= "fetch") then
	print("Usage:")
	print("packman <install|update|remove> <package name[s]>")
	print("packman fetch")
	return
end

--lower all arguments
for i = 1, #args do
	args[i] = string.lower(args[i])
end

local mode = ""

function resetScreen()
	term.clear()
	term.setCursorPos(1,1)
	xlim, ylim = term.getSize()
	if xlim >= 9 then
		term.setTextColor(colors.black)
		term.setBackgroundColor(colors.white)
		term.write(" PackMan"..string.rep(" ", xlim - 8))
		term.setCursorPos(1,2)
		term.setTextColor(colors.white)
		term.setBackgroundColor(colors.black)
	end
end

function printError(errorText)
	if term.isColor() then term.setTextColor(colors.red) end
	print(errorText)
	term.setTextColor(colors.white)
	error()
end

package.printError = printError

function printWarning(warningText)
	if term.isColor() then term.setTextColor(colors.yellow) end
	print(warningText)
	term.setTextColor(colors.white)
end

package.printWarning = printWarning

function printInformation(infoText)
	if term.isColor() then term.setTextColor(colors.lime) end
	print(infoText)
	term.setTextColor(colors.white)
end

package.printInformation = printInformation

resetScreen()

local categoryList = {}
local categorySorted = {}

if args[1] ~= "fetch" then
	for n, v in pairs(package.list) do
		for str in string.gmatch(v.category, "(%S+)") do
			if not categoryList[str] then
				categoryList[str] = {[n] = true}
				table.insert(categorySorted, str)
			else
				categoryList[str][n] = true
			end
		end
	end
	table.sort(categorySorted)

	--flesh out dependencies
	for pName, pData in pairs(package.list) do
		pData.dependencies, errmsg = package.findDependencies(pName, {})
		if not pData.dependencies then
			--if dependencies could not be resolved, remove the package.
			printWarning("Could not resolve dependency on "..errmsg.." in package "..pName)
			package.list[pName] = nil
		end
	end
end

local mode = table.remove(args, 1)

if mode == "install" then
	if #args >= 1 then
		local installList = {}
		for packageNumber, packageName in ipairs(args) do
			if not package.list[packageName] then
				printWarning("Could not install package "..packageName..".")
			else
				for k,v in pairs(package.list[packageName].dependencies) do
					installList[k] = true
				end
			end
		end
		local installString = ""
		for k, v in pairs(installList) do
			installString = installString..k.." "
		end
		if #installString > 0 then
			print("The following packages will be installed: "..installString)
			print("Continue? (Y/n)")
			local input = read()
			if string.sub(input:lower(), 1, 1) == "n" then
				return true
			else
				for packageName in pairs(installList) do
					if not package.install(packageName) then printWarning("Could not "..mode.." package "..packageName) end
				end
			end
		end
	end
elseif mode == "update" then
	local updateList = {}
	if #args >= 1 then
		updateList = args
	else
		for k, v in pairs(package.installed) do
			table.insert(updateList, k)
		end
	end
	for i = #updateList, 1, -1 do
		if package.installed[updateList[i]].version == package.list[updateList[i]].version then
			table.remove(updateList, i)
		end
	end
	if #updateList > 0 then
		local updateString = ""
		for i = 1, #updateList do
			updateString = updateString..updateList[i].." "
		end
		print("The following packages will be updated: "..updateString)
		print("Continue? (Y/n)")
		local input = read()
		if string.sub(input:lower(), 1, 1) == "n" then
			return true
		else
			for _, packageName in pairs(updateList) do
				removePackage(packageName)
				installPackage(packageName)
			end
		end
	else
		print("Nothing to do!")
		return true
	end
elseif mode == "remove" then
	if #args >= 1 then
		for i = #args, 1, -1 do
			if not package.installed[args[1]] then
				table.remove(args, i)
			end
		end
		local packageList = args
		dependeesList = {}
		--find packages which depend on the packages we are removing.
		for pName, pData in pairs(package.list) do
			if not packageList[pName] then
				for dName in pairs(pData.dependencies) do
					for _, packName in pairs(packageList) do
						if packName == dName then
							dependeesList[pName] = true
							break
						end
					end
					if dependeesList[pName] then
						break
					end
				end
			end
		end
		local removeString = ""
		local dependeesString = ""
		for i = 1, #packageList do
			removeString = removeString..packageList[i].." "
			if dependeesList[packageList[i]] then
				dependeesList[packageList[i]] = nil
			end
		end
		for dName in pairs(dependeesList) do
			dependeesString = dependeesString..dName.." "
		end
		if #removeString > 0 then
			print("The following packages will be removed: "..removeString)
			if #dependeesString > 0 then
				print("The following packages will also be removed due to missing dependencies: "..dependeesString)
			end
			print("Continue? (y/N)")
			local input = read()
			if string.sub(input:lower(), 1, 1) == "y" then
				for _, pName in pairs(packageList) do
					package.remove(pName)
				end
				for pName in pairs(dependeesList) do
					package.remove(pName)
				end
			else
				return true
			end
		else
			print("Nothing to do!")
		end
	end
elseif mode == "fetch" then
	print("Updating Installer")
	local remoteHandle = http.get("https://raw.github.com/lyqyd/cc-packman/master/packman")
	if remoteHandle then
		fileHandle = io.open(shell.getRunningProgram(), "w")
		if fileHandle then
			fileHandle:write(remoteHandle.readAll())
			fileHandle:close()
		else
			printWarning("Could not open file "..shell.getRunningProgram())
		end
	else
		printWarning("Could not retrieve remote file.")
	end
	print("Fetching Repository List")
	remoteHandle = http.get("https://raw.github.com/lyqyd/cc-packman/master/repolist")
	if remoteHandle then
		if not fs.exists("/etc") then fs.makeDir("/etc") end
		fileHandle = io.open("/etc/repolist", "w")
		if fileHandle then
			fileHandle:write(remoteHandle.readAll())
			fileHandle:close()
			os.unloadAPI("package")
			if not os.loadAPI("package") then printError("Could not reload package API") end
		else
			printError("Could not open file /etc/repolist")
		end
	else
		printError("Could not retrieve remote file: repolist")
	end
	while args[1] == "fetch" do
		table.remove(args, 1)
	end
	if #args > 0 then
		while args[1] == "fetch" do
			table.remove(args, 1)
		end
		shell.run(shell.getRunningProgram(), unpack(args))
		return
	end
end

--[[
term.clear()
term.setCursorPos(1,1)
]]