local versionNumber = 1.1

local args = {...}

if #args < 1 or (args[1] ~= "install" and args[1] ~= "update" and args[1] ~= "remove" and args[1] ~= "interactive" and args[1] ~= "fetch") then
	print("Usage:")
	print("packman <install|update|remove> <package name[s]>")
	print("packman interactive")
	print("packman fetch")
	return
end

--lower all arguments
for i = 1, #args do
	args[i] = string.lower(args[i])
end

local mode = ""

function resetScreen()
	term.clear()
	term.setCursorPos(1,1)
	xlim, ylim = term.getSize()
	if mode == "interactive" then
		if xlim >= 9 then
			term.write("=PackMan"..string.rep("=", xlim - 8))
			term.setCursorPos(1,2)
		end
	end
end

function printError(errorText)
	if term.isColor() then term.setTextColor(colors.red) end
	print(errorText)
	term.setTextColor(colors.white)
	error()
end

function printWarning(warningText)
	if term.isColor() then term.setTextColor(colors.yellow) end
	print(warningText)
	term.setTextColor(colors.white)
end

function printInformation(infoText)
	if term.isColor() then term.setTextColor(colors.lime) end
	print(infoText)
	term.setTextColor(colors.white)
end

installedPackages = {}

--build installed packages list from saved database.
if fs.exists(".instPacks") then
	local dbHandle = io.open(".instPacks", "r")
	if dbHandle then
		local package = ""
		local entryTable
		for line in dbHandle:lines() do
			if string.match(line, "(=)") then
				--new entry table time
				if entryTable then
					if not installedPackages[entryTable.name] then
						installedPackages[entryTable.name] = entryTable
					else
						printError("Database is corrupt!")
					end
				end
				entryTable = {files = {}}
				entryTable.name, entryTable.version = string.match(line, "(.-)=(.*)")
			else
				table.insert(entryTable.files, line)
			end
		end
		--catch final entry table.
		if entryTable and entryTable.name then
			if not installedPackages[entryTable.name] then
				installedPackages[entryTable.name] = entryTable
			else
				printError("Database is corrupt!")
			end
		end
		dbHandle:close()
	end
end

function updateDatabase(packageName, packageVersion, fileTable)
	installedPackages[packageName] = {
		name = packageName,
		version = packageVersion,
		files = {}
	}
	for i = 1, #fileTable do
		installedPackages[packageName].files[i] = fileTable[i]
	end
end

function writeDatabase()
	local dbHandle = io.open(".instPacks", "w")
	for _, package in pairs(installedPackages) do
		dbHandle:write(package.name.."="..package.version.."\n")
		for i = 1, #package.files do
			dbHandle:write(package.files[i].."\n")
		end
	end
	dbHandle:close()
end

local packAPI = {
	pathList = {}
}

function packAPI.addFile(path)
	table.insert(packAPI.pathList, path)
end

function packAPI.removeFile(path)
	for i = #packAPI.pathList, 1, -1 do
		if packAPI.pathList[i] == path then
			table.remove(packAPI.pathList, i)
		end
	end
end

local downloadTypes = {
	github = {
		author = true,
		repository = true,
	},
	bitbucket = {
		author = true,
		repository = true,
	},
	pastebin = {
		url = true,
		filename = true,
	},
	raw = {
		url = true,
		filename = true,
	},
}

downloadFunctions = {}

downloadFunctions.raw = function(url, path)
	if type(url) == "table" then
		local package = url
		url = package.url
		path = fs.combine(package.target, package.filename)
	end
	printInformation("Fetching: "..url)
	http.request(url)
	while true do
		event, url, sourceText = os.pullEvent()
		if event == "http_success" then
			if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
				fs.makeDir(string.match(path, "(.-)/[^/]+$"))
				packAPI.addFile(string.match(path, "(.-)/[^/]+$"))
			end
			local fileHandle = io.open(path, "w")
			if fileHandle then
				fileHandle:write(sourceText.readAll())
				fileHandle:close()
				packAPI.addFile(path)
			else
				printWarning("Unable to open file "..path)
			end
			printInformation("Done!")
			return true
		else
			printWarning("Unable to fetch file "..url)
			return false
		end
	end
end

downloadFunctions.github = function(package)
	local function getDirectoryContents(path)
		local fType, fPath = {}, {}
		local response = http.get("https://api.github.com/repos/"..package.author.."/"..package.repository.."/contents/"..path)
		if response then
			response = response.readAll()
			if response ~= nil then
				for str in response:gmatch('"type":%s*"(%w+)",') do table.insert(fType, str) end
				for str in response:gmatch('"path":%s*"([^\"]+)",') do table.insert(fPath, str) end
			end
		else
			printWarning("Can't fetch repository information")
			return nil
		end
		local directoryContents = {}
		for i=1, #fType do
			directoryContents[i] = {type = fType[i], path = fPath[i]}
		end
		return directoryContents
	end
	local function addDirectoryContents(path, contentsTable)
		local contents = getDirectoryContents(path)
		if not contents then return nil, "no contents" end
		for n, file in ipairs(contents) do
			if file.type == "dir" then
				addDirectoryContents(file.path, contentsTable)
			else
				table.insert(contentsTable, file.path)
			end
		end
		return contentsTable
	end
	local contents = addDirectoryContents("", {})
	if not contents then return nil, "content fetch failure" end
	local localTarget = package.target or ""
	for num, fileName in ipairs(contents) do
		if not downloadFunctions.raw("https://raw.github.com/"..package.author.."/"..package.repository.."/master/"..fileName, fs.combine(localTarget, fileName)) then return false end
	end
	return true
end

downloadFunctions.bitbucket = function(package)
	local function getDirectoryContents(path)
		local directoryContents = {}
		local response = http.get("https://api.bitbucket.org/1.0/repositories/"..package.author.."/"..package.repository.."/src/default"..path)
		if response then
			response = response.readAll()
			if response ~= nil then
				for str in string.gmatch(string.match(response, '"directories": %[(.-)%]'), '"([^,\"]+)"') do table.insert(directoryContents, {type = "dir", path = str}) end
				for str in string.gmatch(string.match(response, '"files": %[(.-)%]'), '"path": "([^\"]+)"') do table.insert(directoryContents, {type = "file", path = str}) end
			end
		else
			printWarning("Can't fetch repository information")
			return nil
		end
		return directoryContents
	end
	local function addDirectoryContents(path, contentsTable)
		local contents = getDirectoryContents(path)
		for n, file in ipairs(contents) do
			if file.type == "dir" then
				addDirectoryContents(path..file.path.."/", contentsTable)
			else
				table.insert(contentsTable, file.path)
			end
		end
		return contentsTable
	end
	local contents = addDirectoryContents("/", {})
	local localTarget = package.target or ""
	for num, fileName in ipairs(contents) do
		if not downloadFunctions.raw("https://bitbucket.org/"..package.author.."/"..package.repository.."/raw/default/"..fileName, fs.combine(localTarget, fileName)) then return false end
	end
	return true
end

downloadFunctions.pastebin = function(package)
	return downloadFunctions.raw("http://pastebin.com/raw.php?i="..package.url, fs.combine(package.target, package.filename))
end

resetScreen()

local packageTable = {}

if args[1] ~= "fetch" then
	--construct package table.
	local state = ""
	local listHandle = io.open("/usr/repolist", "r")
	local entryTable
	local lineCount = 1
	if listHandle then
		for line in listHandle:lines() do
			if state == "type" then
				local allAttributes = true
				for attribute in pairs(downloadTypes[entryTable.type]) do
					if not entryTable[attribute] then
						allAttributes = false
						break
					end
				end
				if allAttributes then
					state = "main"
				end
			end
			local property = string.match(line, "^%s*(%S*)")
			if property == "name" and state == "" then
				if state == "" then
					entryTable = {name = string.lower(string.match(line, "^%s*name%s*=%s*(%S*)"))}
					state = "main"
				else
					if state ~= "dirty" then
						printWarning("Unexpected 'name' at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "type" then
				if state == "main" then
					entryTable.type = string.match(line, "^%s*type%s*=%s*(%S*)")
					if downloadFunctions[entryTable.type] then
						state = "type"
					else
						if state ~= "dirty" then
							printWarning("Unknown Repository Format at line "..lineCount)
							state = "dirty"
						end
					end
				else
					if state ~= "dirty" then
						printWarning("Unexpected 'type' at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "category" or property == "target" or property == "setup" or property == "remove" or property == "version" then
				if state == "main" then
					entryTable[property] = string.match(line, "^%s*"..property.."%s*=%s*(.*)")
				else
					if state ~= "dirty" then
						printWarning("Unexpected "..property.." at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "dependencies" then
				if state == "main" then
					entryTable.dependencies = {}
					for packName in string.gmatch(string.match(line, "^%s*"..property.."%s*=%s*(.*)"), "(%S+)") do
						entryTable.dependencies[packName] = true
					end
				else
					if state ~= "dirty" then
						printWarning("Unexpected dependencies at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "end" then
				if state == "dirty" then
					state = ""
				elseif state == "type" then
					printWarning("Unexpected end at line "..lineCount)
					state = ""
				elseif state == "main" then
					--this line is the required entries for a valid repolist entry.
					if entryTable.dependencies and entryTable.type and entryTable.category and entryTable.version then
						if not entryTable.target then entryTable.target = "" end
						packageTable[entryTable.name] = entryTable
					else
						entryTable = nil
					end
					state = ""
				end
			elseif state == "type" then
				local propertyFound = false
				for prop in pairs(downloadTypes[entryTable.type]) do
					if property == prop then
						propertyFound = true
						break
					end
				end
				if propertyFound then
					entryTable[property] = string.match(line, "^%s*"..property.."%s*=%s*(%S*)")
				else
					printWarning("Unexpected "..property.." at line "..lineCount)
					state = "dirty"
				end
			end
			lineCount = lineCount + 1
		end
		if state ~= "" then
			printWarning("Expected 'end' at line "..lineCount)
		end
		listHandle:close()
	else
		printError("Could not open repository list!")
	end

	local categoryList= {}
	for n, v in pairs(packageTable) do
		for str in string.gmatch(v.category, "(%S+)") do
			if not categoryList[str] then
				categoryList[str] = {[n] = true}
			else
				categoryList[str][n] = true
			end
		end
	end

	function addDependencies(packageName, dependencyTable)
		if packageTable[packageName] then
			dependencyTable[packageName] = true
			for packName in pairs(packageTable[packageName].dependencies) do
				if packName ~= "none" and not dependencyTable[packName] then
					dependencyTable, errmsg = findDependencies(packName, dependencyTable)
					if not dependencyTable then return nil, errmsg end
				end
			end
		else
			return nil, packageName
		end
		return dependencyTable
	end

	--flesh out dependencies
	for pName, pData in pairs(packageTable) do
		pData.dependencies, errmsg = addDependencies(pName, {})
		if not pData.dependencies then
			--if dependencies could not be resolved, remove the package.
			printWarning("Could not resolve dependency on "..errmsg.." in package "..pName)
			packageTable[pName] = nil
		end
	end
end

function installPackage(packageName)
	local package = packageTable[packageName]
	if downloadFunctions[package.type] then
		if not downloadFunctions[package.type](package) then return false end
	end
	if package.setup then
		local setupTable = {}
		for match in string.gmatch(package.setup, "(%S+)") do
			table.insert(setupTable, match)
		end
		local programPath = fs.combine(package.target, table.remove(setupTable, 1))
		os.run({packman = packAPI, __index = _G}, programPath, unpack(setupTable))
		--record and reset the API's internal path list for subsequent package use.
		packAPI.pathList = {}
		resetScreen()
	end
	updateDatabase(packageName, packageTable[packageName].version, packAPI.pathList)
	writeDatabase()
	return true
end

function removePackage(packageName)
	local package = packageTable[packageName]
	if package.remove then
		local removeTable = {}
		for match in string.gmatch(package.remove, "(%S+)") do
			table.insert(removeTable, match)
		end
		local programPath = fs.combine(package.target, table.remove(setupTable, 1))
		os.run({packman = packAPI, __index = _G}, programPath, unpack(setupTable))
	end
	local fileList = installedPackages[packageName].files
	for i = 1, #fileList do
		if fs.exists(fileList[i]) then
			if fs.isDir(fileList[i]) then
				if #fs.list(fileList[i]) == 0 then
					fs.delete(fileList[i])
				end
			else
				fs.delete(fileList[i])
			end
		end
	end
	--remove package from list of installed packages.
	installedPackages[packageName] = nil
	writeDatabase()
end

local mode = table.remove(args, 1)

if mode == "install" then
	if #args >= 1 then
		local installList = {}
		for packageNumber, packageName in ipairs(args) do
			if not packageTable[packageName] then
				printWarning("Could not install package "..packageName..".")
			else
				for k,v in pairs(packageTable[packageName].dependencies) do
					installList[k] = true
				end
			end
		end
		local installString = ""
		for k, v in pairs(installList) do
			installString = installString..k.." "
		end
		if #installString > 0 then
			print("The following packages will be installed: "..installString)
			print("Continue? (Y/n)")
			local input = read()
			if string.sub(input:lower(), 1, 1) == "n" then
				return true
			else
				for packageName in pairs(installList) do
					if not installPackage(packageName) then printWarning("Could not "..mode.." package "..packageName) end
				end
			end
		end
	end
elseif mode == "update" then
	local updateList = {}
	if #args >= 1 then
		updateList = args
	else
		for k, v in pairs(installedPackages) do
			table.insert(updateList, k)
		end
	end
	for i = #updateList, 1, -1 do
		if installedPackages[updateList[i]].version == packageTable[updateList[i]].version then
			table.remove(updateList, i)
		end
	end
	if #updateList > 0 then
		local updateString = ""
		for i = 1, #updateList do
			updateString = updateString..updateList[i].." "
		end
		print("The following packages will be updated: "..updateString)
		print("Continue? (Y/n)")
		local input = read()
		if string.sub(input:lower(), 1, 1) == "n" then
			return true
		else
			for _, packageName in pairs(updateList) do
				removePackage(packageName)
				installPackage(packageName)
			end
		end
	else
		print("Nothing to do!")
		return true
	end
elseif mode == "remove" then
	if #args >= 1 then
		for i = #args, 1, -1 do
			if not installedPackages[args[1]] then
				table.remove(args, i)
			end
		end
		local packageList = args
		dependeesList = {}
		--find packages which depend on the packages we are removing.
		for pName, pData in pairs(packageTable) do
			if not packageList[pName] then
				for dName in pairs(pData.dependencies) do
					for _, packName in pairs(packageList) do
						if packName == dName then
							dependeesList[pName] = true
							break
						end
					end
					if dependeesList[pName] then
						break
					end
				end
			end
		end
		local removeString = ""
		local dependeesString = ""
		for i = 1, #packageList do
			removeString = removeString..packageList[i].." "
			if dependeesList[packageList[i]] then
				dependeesList[packageList[i]] = nil
			end
		end
		for dName in pairs(dependeesList) do
			dependeesString = dependeesString..dName.." "
		end
		if #removeString > 0 then
			print("The following packages will be removed: "..removeString)
			if #dependeesString > 0 then
				print("The following packages will also be removed due to missing dependencies: "..dependeesString)
			end
			print("Continue? (y/N)")
			local input = read()
			if string.sub(input:lower(), 1, 1) == "y" then
				for _, pName in pairs(packageList) do
					removePackage(pName)
				end
				for pName in pairs(dependeesList) do
					removePackage(pName)
				end
			else
				return true
			end
		else
			print("Nothing to do!")
		end
	end
elseif mode == "fetch" then
	print("Updating Installer")
	local remoteHandle = http.get("https://raw.github.com/lyqyd/cc-packman/master/packman")
	if remoteHandle then
		fileHandle = io.open(shell.getRunningProgram(), "w")
		if fileHandle then
			fileHandle:write(remoteHandle.readAll())
			fileHandle:close()
		else
			printWarning("Could not open file "..shell.getRunningProgram())
		end
	else
		printWarning("Could not retrieve remote file.")
	end
	print("Fetching Repository List")
	remoteHandle = http.get("https://raw.github.com/lyqyd/cc-packman/master/repolist")
	if remoteHandle then
		if not fs.exists("/usr") then fs.makeDir("/usr") end
		fileHandle = io.open("/usr/repolist", "w")
		if fileHandle then
			fileHandle:write(remoteHandle.readAll())
			fileHandle:close()
		else
			printError("Could not open file /usr/repolist")
		end
	else
		printError("Could not retrieve remote file: repolist")
	end
	while args[1] == "fetch" do
		table.remove(args, 1)
	end
	if #args > 0 then
		local fileHandle = io.open(shell.getRunningProgram(), "r")
		if fileHandle then
			local newVersionNumber = tonumber(string.match(fileHandle:read("*l"), "local versionNumber = (.*)"))
			fileHandle:close()
			if newVersionNumber > versionNumber then
				shell.run(shell.getRunningProgram(), unpack(args))
				return
			end
		end
	end
elseif mode == "interactive" then
	--interactive mode
end

--[[
term.clear()
term.setCursorPos(1,1)
]]