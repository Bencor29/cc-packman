local versionNumber = 1.1

local args = {...}

if #args < 1 or (args[1] ~= "install" and args[1] ~= "update" and args[1] ~= "remove" and args[1] ~= "interactive" and args[1] ~= "fetch") then
	print("Usage:")
	print("packman <install|update|remove> <package name[s]>")
	print("packman interactive")
	print("packman fetch")
	return
end

local mode = ""

function resetScreen()
	term.clear()
	term.setCursorPos(1,1)
	xlim, ylim = term.getSize()
	if mode == "interactive" then
		if xlim >= 9 then
			term.write("=PackMan"..string.rep("=", xlim - 8))
			term.setCursorPos(1,2)
		end
	end
end

function printError(errorText)
	if term.isColor() then term.setTextColor(colors.red) end
	print(errorText)
	term.setTextColor(colors.white)
	error()
end

function printWarning(warningText)
	if term.isColor() then term.setTextColor(colors.yellow) end
	print(warningText)
	term.setTextColor(colors.white)
end

function printInformation(infoText)
	if term.isColor() then term.setTextColor(colors.green) end
	print(infoText)
	term.setTextColor(colors.white)
end

installedPackages = {}

--build installed packages list from saved database.
local dbHandle = io.open(".instPacks", "r")
if dbHandle then
	local package = ""
	local entryTable
	for line in dbHandle:lines() do
		if string.match(line, "(=)") then
			--new entry table time
			if entryTable then
				if not installedPackages[entryTable.name] then
					installedPackages[entryTable.name] = entryTable
				else
					printError("Database is corrupt!")
				end
			end
			entryTable = {name, version = string.match(line, "(.-)=(.*)"), files = {}}
		else
			table.insert(entryTable.files, line)
		end
	end
	--catch final entry table.
	if entryTable then
		if not installedPackages[entryTable.name] then
			installedPackages[entryTable.name] = entryTable
		else
			printError("Database is corrupt!")
		end
	end
	dbHandle:close()
end

function updateDatabase(packageName, packageVersion, fileTable)
	installedPackages[packageName] = {
		name = packageName,
		version = packageVersion,
		files = {}
	}
	for i = 1, #fileTable do
		installedPackages[packageName].files[i] = fileTable[i]
	end
end

function writeDatabase()
	local dbHandle = io.open(".instPacks", "w")
	for _, package in pairs(installedPackages) do
		dbHandle:write(package.name.."="..package.version.."\n")
		for i = 1, #package.files do
			dbHandle:write(package.files[i].."\n")
		end
	end
	dbHandle:close()
end

local packAPI = {
	pathList = {}
}

function packAPI.addFile(path)
	table.insert(packAPI.pathList, path)
end

function packAPI.removeFile(path)
	for i = #packAPI.pathList, 1, -1 do
		if packAPI.pathList[i] == path then
			table.remove(packAPI.pathList, i)
		end
	end
end

local downloadTypes = {
	github = {
		author = true,
		repository = true,
	},
	bitbucket = {
		author = true,
		repository = true,
	}
}

downloadFunctions = {}

downloadFunctions.raw = function(url, path)
	if type(url) == "table" then
		local package = url
		url = package.url
		path = fs.combine(package.target, package.filename)
	end
	printInformation("Fetching: "..url)
	http.request(url)
	while true do
		event, url, sourceText = os.pullEvent()
		if event == "http_success" then
			if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
				fs.makeDir(string.match(path, "(.-)/[^/]+$"))
				packAPI.addFile(string.match(path, "(.-)/[^/]+$"))
			end
			local fileHandle = io.open(path, "w")
			if fileHandle then
				fileHandle:write(sourceText.readAll())
				fileHandle:close()
				packAPI.addFile(path)
			else
				printWarning("Unable to open file "..path)
			end
			printInformation("Done!")
			return true
		else
			printWarning("Unable to fetch file "..url)
			return false
		end
	end
end

downloadFunctions.github = function(package)
	local function getDirectoryContents(path)
		local fType, fPath = {}, {}
		local response = http.get("https://api.github.com/repos/"..package.author.."/"..package.repository.."/contents/"..path)
		if response then
			response = response.readAll()
			if response ~= nil then
				for str in response:gmatch('"type":%s*"(%w+)",') do table.insert(fType, str) end
				for str in response:gmatch('"path":%s*"([^\"]+)",') do table.insert(fPath, str) end
			end
		else
			printWarning("Can't fetch repository information")
			return nil
		end
		local directoryContents = {}
		for i=1, #fType do
			directoryContents[i] = {type = fType[i], path = fPath[i]}
		end
		return directoryContents
	end
	local function addDirectoryContents(path, contentsTable)
		local contents = getDirectoryContents(path)
		for n, file in ipairs(contents) do
			if file.type == "dir" then
				addDirectoryContents(file.path, contentsTable)
			else
				table.insert(contentsTable, file.path)
			end
		end
		return contentsTable
	end
	local contents = addDirectoryContents("", {})
	local localTarget = package.target or ""
	for num, fileName in ipairs(contents) do
		if not downloadFunctions.raw("https://raw.github.com/"..package.author.."/"..package.repository.."/master/"..fileName, fs.combine(localTarget, fileName)) then return false end
	end
	return true
end

downloadFunctions.bitbucket = function(package)
	local function getDirectoryContents(path)
		local directoryContents = {}
		local response = http.get("https://api.bitbucket.org/1.0/repositories/"..package.author.."/"..package.repository.."/src/default"..path)
		if response then
			response = response.readAll()
			if response ~= nil then
				for str in string.gmatch(string.match(response, '"directories": %[(.-)%]'), '"([^,\"]+)"') do table.insert(directoryContents, {type = "dir", path = str}) end
				for str in string.gmatch(string.match(response, '"files": %[(.-)%]'), '"path": "([^\"]+)"') do table.insert(directoryContents, {type = "file", path = str}) end
			end
		else
			printWarning("Can't fetch repository information")
			return nil
		end
		return directoryContents
	end
	local function addDirectoryContents(path, contentsTable)
		local contents = getDirectoryContents(path)
		for n, file in ipairs(contents) do
			if file.type == "dir" then
				addDirectoryContents(path..file.path.."/", contentsTable)
			else
				table.insert(contentsTable, file.path)
			end
		end
		return contentsTable
	end
	local contents = addDirectoryContents("/", {})
	local localTarget = package.target or ""
	for num, fileName in ipairs(contents) do
		if not downloadFunctions.raw("https://bitbucket.org/"..package.author.."/"..package.repository.."/raw/default/"..fileName, fs.combine(localTarget, fileName)) then return false end
	end
	return true
end

downloadFunctions.pastebin = function(package)
	return downloadFunctions.raw("http://pastebin.com/raw.php?i="..package.url, fs.combine(package.target, package.filename))
end

resetScreen()

local packageTable = {}

if args[1] ~= "fetch" then
	--construct package table.
	local state = ""
	local listHandle = io.open("/usr/repolist", "r")
	local entryTable
	local lineCount = 1
	if listHandle then
		for line in listHandle:lines() do
			if state == "type" then
				local allAttributes = true
				for attribute in pairs(downloadTypes[entryTable.type]) do
					if not entryTable[attribute] then
						allAttributes = false
						break
					end
				end
				if allAttributes then
					state = "main"
				end
			end
			local property = string.match(line, "^%s*(%S*)")
			if property == "name" and state == "" then
				if state == "" then
					entryTable = {name = string.match(line, "^%s*name%s*=%s*(%S*)")}
					state = "main"
				else
					if state ~= "dirty" then
						printWarning("Unexpected 'name' at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "type" then
				if state == "main" then
					entryTable.type = string.match(line, "^%s*type%s*=%s*(%S*)")
					if downloadFunctions[entryTable.type] then
						state = "type"
					else
						if state ~= "dirty" then
							printWarning("Unknown Repository Format at line "..lineCount)
							state = "dirty"
						end
					end
				else
					if state ~= "dirty" then
						printWarning("Unexpected 'type' at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "category" or property == "target" or property == "setup" or property == "remove" or property == "dependencies" or property == "version" then
				if state == "main" then
					entryTable[property] = string.match(line, "^%s*"..property.."%s*=%s*(.*)")
				else
					if state ~= "dirty" then
						printWarning("Unexpected "..property.." at line "..lineCount)
						state = "dirty"
					end
				end
			elseif property == "end" then
				if state == "dirty" then
					state = ""
				elseif state == "type" then
					printWarning("Unexpected end at line "..lineCount)
					state = ""
				elseif state == "main" then
					--this line is the required entries for a valid repolist entry.
					if entryTable.dependencies and entryTable.type and entryTable.category and entryTable.version then
						if not entryTable.target then entryTable.target = "" end
						packageTable[entryTable.name] = entryTable
					else
						entryTable = nil
					end
					state = ""
				end
			elseif state == "type" then
				local propertyFound = false
				for _, prop in pairs(downloadTypes[entryTable.type]) do
					if property == prop then
						propertyFound = true
						break
					end
				end
				if propertyFound then
					entryTable[property] = string.match(line, "^%s*"..property.."%s*=%s*(%S*)")
				else
					printWarning("Unexpected "..property.." at line "..lineCount)
					state = "dirty"
				end
			end
			lineCount = lineCount + 1
		end
		if state ~= "" then
			printWarning("Expected 'end' at line "..lineCount)
		end
		listHandle:close()
	else
		printError("Could not open repository list!")
	end

	local categoryList= {}
	for n, v in pairs(packageTable) do
		for str in string.gmatch(v.category, "(%S+)") do
			if not categoryList[str] then
				categoryList[str] = {[n] = true}
			else
				categoryList[str][n] = true
			end
		end
	end
end

function findDependencies(packageName, dependencyTable)
	if packageTable[packageName] then
		dependencyTable[packageName] = true
		for packName in string.gmatch(packageTable[packageName].dependencies, "(%S+)") do
			if packName ~= "none" and not dependencyTable[packName] then
				dependencyTable, errmsg = findDependencies(packName, dependencyTable)
				if not dependencyTable then return nil, errmsg end
			end
		end
	else
		return nil, packageName
	end
	return dependencyTable
end

function installPackage(packageName)
	local package = packageTable[packageName]
	if downloadFunctions[package.type] then
		if not downloadFunctions[package.type](package) then return false end
	end
	if package.setup then
		local setupTable = {}
		for match in string.gmatch(package.setup, "(%S+)") do
			table.insert(setupTable, match)
		end
		local programPath = fs.combine(package.target, table.remove(setupTable, 1))
		os.run({packman = packAPI, __index = _G}, programPath, unpack(setupTable))
		--record and reset the API's internal path list for subsequent package use.
		updateDatabase(packageName, packageTable[packageName].version, packAPI.pathList)
		writeDatabase()
		packAPI.pathList = {}
		resetScreen()
	end
	return true
end

local mode = table.remove(args, 1)

if mode == "install" or mode == "update" then
	local installList = {}
	if #args >= 1 then
		for packageNumber, packageName in ipairs(args) do
			local dependencies, errmsg = findDependencies(packageName, {})
			if not dependencies then
				printWarning("Could not "..mode.." package "..packageName.." due to missing dependency: "..errmsg)
			else
				for k,v in pairs(dependencies) do
					installList[k] = true
				end
			end
		end
		local installString = ""
		for k, v in pairs(installList) do
			installString = installString..k.." "
		end
		print("The following packages will be installed: ".. installString)
		print("Continue? (Y/n)")
		local input = read()
		if string.sub(input:lower(), 1, 1) == "n" then
			return true
		else
			for packageName in pairs(installList) do
				if not installPackage(packageName) then printWarning("Could not "..mode.." package "..packageName) end
			end
		end
	end
elseif mode == "remove" then
	if #args >= 1 then
		for packageNumber, packageName in ipairs(args) do
			if packageTable[packageName].remove then
				local removeTable = {}
				for match in string.gmatch(packageTable[packageName].remove, "(%S*)") do
					table.insert(removeTable, match)
				end
				local programPath = fs.combine(packageTable[packageName].target, table.remove(removeTable, 1))
				shell.run(programPath, unpack(removeTable))
			else
				printInformation("Package "..packageName.." must be manually uninstalled from /"..packageTable[packageName].target)
			end
		end
	end
elseif mode == "fetch" then
	print("Updating Installer")
	local remoteHandle = http.get("https://raw.github.com/lyqyd/cc-packman/master/packman")
	if remoteHandle then
		fileHandle = io.open(shell.getRunningProgram(), "w")
		if fileHandle then
			fileHandle:write(remoteHandle.readAll())
			fileHandle:close()
		else
			printWarning("Could not open file "..shell.getRunningProgram())
		end
	else
		printWarning("Could not retrieve remote file.")
	end
	print("Fetching Repository List")
	remoteHandle = http.get("https://raw.github.com/lyqyd/cc-packman/master/repolist")
	if remoteHandle then
		if not fs.exists("/usr") then fs.makeDir("/usr") end
		fileHandle = io.open("/usr/repolist", "w")
		if fileHandle then
			fileHandle:write(remoteHandle.readAll())
			fileHandle:close()
		else
			printError("Could not open file /usr/repolist")
		end
	else
		printError("Could not retrieve remote file: repolist")
	end
	if #args > 0 then
		local fileHandle = io.open(shell.getRunningProgram(), "r")
		if fileHandle then
			local newVersionNumber = tonumber(string.match(fileHandle:read("*l"), "local versionNumber = (.*)"))
			fileHandle:close()
			if newVersionNumber > versionNumber then
				shell.run(shell.getRunningProgram(), unpack(args))
				return
			end
		end
	end
elseif mode == "interactive" then
	--interactive mode
end

--[[
term.clear()
term.setCursorPos(1,1)
]]