list = {}
installed = {}

local transactionQueue = {}

local packAPI = {
	pathList = {}
}

function packAPI.addFile(path, version)
	table.insert(packAPI.pathList, {path = path, version = version})
end

function packAPI.removeFile(path)
	for i = #packAPI.pathList, 1, -1 do
		if packAPI.pathList[i].path == path then
			table.remove(packAPI.pathList, i)
		end
	end
end

local function postStatus(type, text)
	os.queueEvent("package_status", type, text)
	while true do
		local event = {os.pullEvent("package_status")}
		if event[1] == "package_status" then break end
	end
end

local function printInformation(text)
	postStatus("info", text)
end

local function printWarning(text)
	postStatus("warning", text)
end

local function printError(text)
	postStatus("error", text)
end

local downloadTypes = {
	github = {
		author = true,
		repository = true,
	},
	bitbucket = {
		author = true,
		repository = true,
		branch = true,
	},
	pastebin = {
		url = true,
		filename = true,
	},
	raw = {
		url = true,
		filename = true,
	},
	grin = {
		author = true,
		repository = true,
	},
}

local Transaction = {
	writeFile = function(self)
		local handle = io.open(self.path, "w") 
		if handle then
			printInformation("Writing file "..self.path)
			handle:write(self.contents)
			handle:close()
		else
			return false
		end
		return true
	end,
	deleteFile = function(self)
		printInformation("Deleting file "..self.path)
		fs.delete(self.path)
		return true
	end,
	makeDirectory = function(self)
		printInformation("Creating directory "..self.path)
		fs.makeDir(self.path)
		return true
	end,
	removeDirectory = function(self)
		printInformation("Removing directory"..self.path)
		fs.delete(self.path)
		return true
	end,
}
function Transaction.finish(self)
	if Transaction[self.type] then
		return Transaction[self.type](self)
	else
		return false
	end
end

local tmeta = {__index = Transaction}

local function newTransaction(pack, path, type, contents, version)
	local transaction = {
		pack = pack,
		path = path,
		type = type,
		contents = contents,
		version = version,
	}

	setmetatable(transaction, tmeta)

	return transaction
end

local lookupFunctions = {}

lookupFunctions.github = function(package)
	local function getDirectoryContents(path)
		local fType, fPath, fVer = {}, {}, {}
		local response = http.get("https://api.github.com/repos/"..package.download.author.."/"..package.download.repository.."/contents/"..path)
		if response then
			response = response.readAll()
			if response ~= nil then
				for str in response:gmatch('"type":%s*"(%w+)",') do table.insert(fType, str) end
				for str in response:gmatch('"path":%s*"([^\"]+)",') do table.insert(fPath, str) end
				for str in response:gmatch('"sha":%s*"([^\"]+)",') do table.insert(fVer, str) end
			end
		else
			printWarning("Can't fetch repository information")
			return nil
		end
		local directoryContents = {}
		for i=1, #fType do
			directoryContents[i] = {type = fType[i], path = fPath[i], version = fVer[i]}
		end
		return directoryContents
	end
	local function addDirectoryContents(path, contentsTable)
		local contents = getDirectoryContents(path)
		if not contents then return nil, "no contents" end
		for n, file in ipairs(contents) do
			if file.type == "dir" then
				addDirectoryContents(file.path, contentsTable)
			else
				table.insert(contentsTable, {path = file.path, version = file.version})
			end
		end
		return contentsTable
	end
	return addDirectoryContents("", {})
end

lookupFunctions.bitbucket = function(package)
	local function getDirectoryContents(path)
		local directoryContents = {}
		local response = http.get("https://api.bitbucket.org/1.0/repositories/"..package.download.author.."/"..package.download.repository.."/src/"..package.download.branch..path)
		if response then
			response = response.readAll()
			if response ~= nil then
				for str in string.gmatch(string.match(response, '"directories": %[(.-)%]'), '"([^,\"]+)"') do table.insert(directoryContents, {type = "dir", path = str}) end
				for str, ver in string.gmatch(string.match(response, '"files": %[(.-)%]'), '"path": "([^\"]+)".-"revision": "([^\"]+)"') do table.insert(directoryContents, {type = "file", path = str, version = ver}) end
			end
		else
			printWarning("Can't fetch repository information")
			return nil
		end
		return directoryContents
	end
	local function addDirectoryContents(path, contentsTable)
		local contents = getDirectoryContents(path)
		for n, file in ipairs(contents) do
			if file.type == "dir" then
				addDirectoryContents(path..file.path.."/", contentsTable)
			else
				table.insert(contentsTable, {path = file.path, version = file.version})
			end
		end
		return contentsTable
	end
	return addDirectoryContents("/", {})
end

local function createSingleFolder(pack, path)
	local fullName = pack.repo.."/"..pack.name
	if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
		createSingleFolder(string.match(path, "(.-)/[^/]+$"))
		table.insert(transactionQueue[fullName], newTransaction(pack, path, "makeDirectory"))
	else
		table.insert(transactionQueue[fullName], newTransaction(pack, path, "makeDirectory"))
	end
end

-- Local function to download a url raw
local function raw(url)
	printInformation("Fetching: "..url)
	http.request(url)
	while true do
		local event = {os.pullEvent()}
		if event[1] == "http_success" then
			printInformation("Done!")
			return event[3].readAll()
		elseif event[1] == "http_failure" then
			printWarning("Unable to fetch file "..event[2])
			return false
		end
	end
end

local downloadFunctions = {}

downloadFunctions.raw = function(pack, env)
	-- Delegate to local raw
	local fullName = pack.repo.."/"..pack.name
	local path = fs.combine(pack.target, pack.download.filename)

	if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
		createSingleFolder(pack, string.match(path, "(.-)/[^/]+$"))
	end
	local content = raw(pack.download.url)
	if content then
		table.insert(transactionQueue[fullName], newTransaction(pack, path, "writeFile", content))
		return true
	else
		return false
	end
end

downloadFunctions.github = function(pack, env)
	local fullName = pack.repo.."/"..pack.name
	local contents = lookupFunctions.github(pack)
	if not contents then return nil, "content fetch failure" end
	local localTarget = pack.target or ""
	for num, file in ipairs(contents) do
		local path = fs.combine(localTarget, file.path)
		if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
			createSingleFolder(pack, string.match(path, "(.-)/[^/]+$"))
		end
		local content = raw("https://raw.github.com/"..pack.download.author.."/"..pack.download.repository.."/master/"..file.path)
		if content then
			table.insert(transactionQueue[fullName], newTransaction(pack, path, "writeFile", content, file.version))
		else
			return false
		end
	end
	return true
end

downloadFunctions.bitbucket = function(pack, env)
	local fullName = pack.repo.."/"..pack.name
	local contents = lookupFunctions.bitbucket(pack)
	local localTarget = pack.target or ""
	for num, file in ipairs(contents) do
		local path = fs.combine(localTarget, file.path)
		if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
			createSingleFolder(pack, string.match(path, "(.-)/[^/]+$"))
		end
		local content = raw("https://bitbucket.org/"..pack.download.author.."/"..pack.download.repository.."/raw/"..pack.download.branch.."/"..file.path)
		if content then
			table.insert(transactionQueue[fullName], newTransaction(pack, path, "writeFile", content, file.version))
		else
			return false
		end
	end
	return true
end

downloadFunctions.pastebin = function(pack, env)
	local fullName = pack.repo.."/"..pack.name
	local path = fs.combine(pack.target, pack.download.filename) 

	if string.match(path, "(.-)/[^/]+$") and not fs.exists(string.match(path, "(.-)/[^/]+$")) then
		createSingleFolder(pack, string.match(path, "(.-)/[^/]+$"))
	end
	local content = raw("http://pastebin.com/raw.php?i="..pack.download.url)
	if content then
		table.insert(transactionQueue[fullName], newTransaction(pack, path, "writeFile", content))
		return true
	else
		return false
	end
end

downloadFunctions.grin = function(pack, env)
	local fullName = pack.repo.."/"..pack.name
	local status
	parallel.waitForAny(function()
		status = env.shell.run("pastebin run VuBNx3va -e -u", pack.download.author, "-r", pack.download.repository, fs.combine(pack.target, pack.name))
	end, function()
		while true do
			local e, msg = os.pullEvent("grin_install_status")
			printInformation(msg)
		end
	end)
	return status
end

function updateDatabase(pack, transactions, files)
	local fullName = pack.repo.."/"..pack.name
	installed[fullName] = {
		version = pack.version,
		files = {}
	}
	for i = 1, #transactions do
		installed[fullName].files[i] = {path = transactions[i].path, version = transactions[i].version}
	end
	for i = 1, #files do
		installed[fullName].files[#installed[fullName].files + 1] = files[i]
	end
end

function writeDatabase(pack)
	if pack then
		--update the entry of a specific pack
		local name = pack.repo.."/"..pack.name
		if installed[name] then
			if not fs.exists(fs.combine("/etc/.installed", pack.repo)) then fs.makeDir(fs.combine("/etc/.installed", pack.repo)) end
			local handle = io.open(fs.combine(fs.combine("/etc/.installed", pack.repo), pack.name), "w")
			handle:write(installed[name].version.."\n")
			for i = 1, #installed[name].files do
				if installed[name].files[i].version then
					handle:write(installed[name].files[i].path..";"..installed[name].files[i].version.."\n")
				else
					handle:write(installed[name].files[i].path.."\n")
				end
			end
			handle:close()
		else
			fs.delete(fs.combine("/etc/.installed", name))
		end
	else
		--write all the packages!
		local packageNames = {}
		--both installed
		for name, info in pairs(installed) do
			if info.version then
				packageNames[name] = true
			end
		end
		--and recently uninstalled
		for _, repo in pairs(fs.list("/etc/.installed")) do
			for _, file in pairs(fs.list(fs.combine("/etc/.installed", repo))) do
				packageNames[repo.."/"..file] = true
			end
		end
		for name in pairs(packageNames) do
			writeDatabase(package.list[name])
		end
	end
end

local function findInstalledVersionByPath(packName, path)
	for i, file in ipairs(package.installed[packName].files) do
		if file.path == path then return file.version end
	end
end

local scriptEnv = {packman = packAPI}
setmetatable(scriptEnv, {__index = _G})

local Package = {
	install = function(self, env)
		local fullName = self.repo.."/"..self.name

		if downloadFunctions[self.download.type] then
			if not transactionQueue[fullName] then transactionQueue[fullName] = {} end
			if not downloadFunctions[self.download.type](self, env) then return false end
		else
			return false
		end

		local queue = transactionQueue[fullName]
		transactionQueue[fullName] = nil
		for i = 1, #queue do
			queue[i]:finish()
		end

		packAPI.pathList = {}
		if self.setup then
			local shell = env.shell
			shell.run(fs.combine(self.target, self.setup))
		end

		updateDatabase(self, queue, packAPI.pathList)
		packAPI.pathList = {}
		writeDatabase(self)
		return true
	end,
	remove = function(self, env)
		local fullName = self.repo.."/"..self.name
		if not package.installed[fullName] then return false end
		if not transactionQueue[fullName] then transactionQueue[fullName] = {} end

		if self.cleanup then
			local shell = env.shell
			shell.run(fs.combine(self.target, self.cleanup))
		end

		local fileList = package.installed[fullName].files
		for i = #fileList, 1, -1 do
			if fs.exists(fileList[i].path) then
				if fs.isDir(fileList[i].path) then
					if #(fs.list(fileList[i].path)) == 0 then
						table.insert(transactionQueue[fullName], newTransaction(self, fileList[i].path, "removeDirectory"))
					end
				else
					table.insert(transactionQueue[fullName], newTransaction(self, fileList[i].path, "deleteFile"))
				end
			end
		end

		local queue = transactionQueue[fullName]
		transactionQueue[fullName] = nil
		for i = 1, #queue do
			queue[i]:finish()
		end

		package.installed[self.name][self.repo] = nil
		local othersWithName = false
		for k, v in pairs(package.installed[self.name]) do
			if v then
				othersWithName = true
				break
			end
		end
		if not othersWithName then
			package.installed[self.name] = nil
		end
		package.installed[self.repo.."/"..self.name] = nil
		writeDatabase(self)
	end,
	upgrade = function(self, env)
		local fullName = self.repo.."/"..self.name
		if not package.installed[fullName] then return false end
		if not transactionQueue[fullName] then transactionQueue[fullName] = {} end
		if lookupFunctions[self.download.type] then
			local contents = lookupFunctions[self.download.type](self)
			for num, file in ipairs(contents) do
				if file.version ~= findInstalledVersionByPath(fullName, file.path) then
					if self.download.type == "github" then
						local path = fs.combine(self.target, file.path)
						local content = raw("https://raw.github.com/"..self.download.author.."/"..self.download.repository.."/master/"..file.path)
						if content then
							table.insert(transactionQueue[fullName], newTransaction(self, path, "writeFile", content, file.version))
						else
							return false
						end
					elseif self.download.type == "bitbucket" then
						local path = fs.combine(self.target, file.path)
						local content = raw("https://bitbucket.org/"..self.download.author.."/"..self.download.repository.."/raw/"..self.download.branch.."/"..file.path)
						if content then
							table.insert(transactionQueue[fullName], newTransaction(self, path, "writeFile", content, file.version))
						else
							return false
						end
					end
				end
			end

			local queue = transactionQueue[fullName]
			transactionQueue[fullName] = nil
			for i = 1, #queue do
				queue[i]:finish()
			end

			updateDatabase(self, queue, packAPI.pathList)
			writeDatabase(self)
			return true
		else
			return self:install(env)
		end
	end,
}

local pmetatable = {__index = Package}

function new(name, repo)
	local p = {
		name = name,
		repo = repo,
		version = "",
		size = 0,
		category = {},
		dependencies = {},
		--installation folder target
		target = "/usr/bin",
		setup = nil,
		remove = nil,
		download = {}
	}

	setmetatable(p, pmetatable)

	return p
end

function findDependencies(packageName, _dependencyTable)
	local dependencyTable = _dependencyTable or {}
	if package.list[packageName] then
		dependencyTable[packageName] = true
		for packName in pairs(package.list[packageName].dependencies) do
			if packName ~= "none" and not dependencyTable[packName] then
				dependencyTable, errmsg = package.findDependencies(packName, dependencyTable)
				if not dependencyTable then return nil, errmsg end
			end
		end
	else
		return nil, packageName
	end
	return dependencyTable
end

if not fs.exists("/usr/bin") then fs.makeDir("/usr/bin") end
--process package list
local function addPacks(file)
	local packName = fs.getName(file)
	local state = ""
	local listHandle = io.open(file, "r")
	local entryTable
	local lineCount = 1
	if listHandle then
		for line in listHandle:lines() do
			if state == "type" then
				local allAttributes = true
				for attribute in pairs(downloadTypes[entryTable.download.type]) do
					if not entryTable.download[attribute] then
						allAttributes = false
						break
					end
				end
				if allAttributes then
					state = "main"
				end
			end
			local property,hasValue,value = string.match(line, "^%s*([^=%s]+)%s*(=?)%s*(.-)%s*$")
			hasValue=hasValue~="" or nil
			if property == "name" and state == "" then
				if state == "" then
					entryTable = new(string.lower(value), packName)
					entryTable.target = "/usr/bin"
					state = "main"
				else
					if state ~= "dirty" then
						printWarning("Unexpected 'name' at line "..lineCount.." in "..file)
						state = "dirty"
					end
				end
			elseif property == "type" then
				if state == "main" then
					entryTable.download.type = string.match(value, "^(%S*)$")
					if downloadFunctions[entryTable.download.type] then
						state = "type"
					else
						if state ~= "dirty" then
							printWarning("Unknown Repository Format at line "..lineCount.." in "..file)
							state = "dirty"
						end
					end
				else
					if state ~= "dirty" then
						printWarning("Unexpected 'type' at line "..lineCount.." in "..file)
						state = "dirty"
					end
				end
			elseif property == "target" or property == "setup" or property == "update" or property == "cleanup" or property == "version" or property == "size" then
				if state == "main" then
					entryTable[property] = value
				else
					if state ~= "dirty" then
						printWarning("Unexpected "..property.." at line "..lineCount.." in "..file)
						state = "dirty"
					end
				end
			elseif property == "dependencies" or property == "category" then
				if state == "main" then
					for str in string.gmatch(value, "(%S+)") do
						entryTable[property][str] = true
					end
				else
					if state ~= "dirty" then
						printWarning("Unexpected "..property.." at line "..lineCount.." in "..file)
						state = "dirty"
					end
				end
			elseif property == "end" then
				if state == "dirty" then
					state = ""
				elseif state == "type" then
					printWarning("Unexpected end at line "..lineCount.." in "..file)
					state = ""
				elseif state == "main" then
					--this line is the required entries for a valid repolist entry.
					if entryTable.download.type and #entryTable.version > 0 and tonumber(entryTable.size) > 0 then
						local i
						for name in pairs(entryTable.dependencies) do
							i = true
							break
						end
						if i then
							list[packName.."/"..entryTable.name] = entryTable
							if list[entryTable.name] then
								list[entryTable.name][packName] = entryTable
							else
								list[entryTable.name] = {[packName] = entryTable}
							end
						end
					else
						entryTable = nil
					end
					state = ""
				end
			elseif state == "type" then
				local propertyFound = false
				for prop in pairs(downloadTypes[entryTable.download.type]) do
					if property == prop then
						propertyFound = true
						break
					end
				end
				if propertyFound then
					entryTable.download[property] = value
				else
					printWarning("Unexpected "..property.." at line "..lineCount.." in "..file)
					state = "dirty"
				end
			end
			lineCount = lineCount + 1
		end
		if state ~= "" then
			printWarning("Expected 'end' at line "..lineCount.." in "..file)
		end
		listHandle:close()
	else
		printError("Could not open repository list!")
	end
end

function load()
	if fs.exists("/etc/repositories") then
		for _, file in ipairs(fs.list("/etc/repositories")) do
			addPacks(fs.combine("/etc/repositories", file))
		end
	end

	if fs.exists("/etc/.installed") and fs.isDir("/etc/.installed") then
		for _, repo in ipairs(fs.list("/etc/.installed")) do
			for _, file in ipairs(fs.list(fs.combine("/etc/.installed", repo))) do
				local name = repo.."/"..file
				local handle = io.open(fs.combine(fs.combine("/etc/.installed", repo), file), "r")
				if handle then
					installed[name] = {files = {}}
					local packVersion
					for line in handle:lines() do
						if not packVersion then
							packVersion = line
							installed[name].version = packVersion
						else
							local path, version = string.match(line, "([^;]+);(.*)")
							if path and version then
								installed[name].files[#installed[name].files + 1] = {path = path, version = version}
							else
								installed[name].files[#installed[name].files + 1] = {path = line, version = packVersion}
							end
						end
					end
					handle:close()
					if installed[file] then
						installed[file][repo] = installed[name]
					else
						installed[file] = {[repo] = installed[name]}
					end
				else
					printWarning("Couldn't open package db file: "..file)
				end
			end
		end
	end
end